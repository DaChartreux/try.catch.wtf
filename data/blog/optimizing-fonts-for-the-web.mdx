---
title: Optimizing fonts for the web
description: Optimize fonts for web applications with minimal affect on UI/UX and lighthouse scores.
heroCreditUserProfile: Brett Jordan
heroCreditUserProfileUrl: https://unsplash.com/@brett_jordan?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText
heroCreditSource: Unsplash
updatedAt: 05 Nov 2021
tags: ["web", "frontend", "performance"]
isPublished: true
---

Adding fonts to your site can make it look better. But they can also affect the performance. In this post, I will share how to use fonts without taking away a huge bite off your lighthouse scores. I also assume that you NEED to use the font, and you cannot get away without using it. So let's get started.

# Potential impacts of fonts

- ### Delayed text rendering

  If a web font has not yet loaded, it can delay text rendering. Resulting in delayed First Contentful Paint (FCP) or even delayed Largest Contentful Paint (LCP) in some cases.

- ### Layout shifts

  When fonts are loaded and swapped, they can cause layout shifts. These layout shifts occur when a web font and its fallback font take up different amounts of space on the page.

What can we do to fix these issues ðŸ¤”?

# Prepping the font to serve

Before we go ahead with anything, let's see how we can optimally serve our font files as fast as possible. If you are using a 3rd party font provider (like Google Fonts), you cannot do much in this case. However, if you are serving the fonts yourself, make sure to serve them (or any static assets) over a CDN and HTTP/2.

A small font file will always be early to the party ðŸ¥³. Keeping that in mind, let's try to reduce the size of our font(s).

### Synthetic weights

Designers hate this simple trick ðŸ˜¡. Instead of downloading multiple weights of the same font, we can load a regular variant (400 weight) and rely on the browser to synthetically create other weights ðŸ˜³. But why do designers hate this trick? It seems to be working perfectly fine, right? In the image below, the red text is the bold variant of Roboto font, and the blue variant is created synthetically from the normal variant. The difference might look subtle, but they can affect the UI and UX.

<ImageSection
  baseUrl="/img/optimizing-fonts-for-the-web"
  srcLight="synthetic-weight.png"
  srcDark="dark-synthetic-weight.png"
  width={548}
  height={237}
  title={
    "Red text is Jost font, 700 weight. Blue text is Jost font, 400 variant, with synthetic 700 weight"
  }
/>

So we cannot get away with loading multiple font variants? ðŸ˜”

### Variable fonts

A variable font has multiple styles like weight, width, slant, optical size, and italics (called axis) of the fonts. The font creator can create several axes, reducing the number of variants you need to download. For this case, we will use the weight axis. If you want to learn more about the other axes or variable fonts, [web.dev](https://web.dev/variable-fonts/) has a great article on it.

<ImageSection
  baseUrl="/img/optimizing-fonts-for-the-web"
  srcLight="variable-font-weight.png"
  srcDark="dark-variable-font-weight.png"
  width={548}
  height={237}
  title={
    "Red text is Jost font, 700 weight. Blue text is Jost variable font with weight as one of its axes"
  }
/>

### Font subsetting

Font subsetting is the process of taking a font file and reducing the number of characters (or character sets). For example, let's say you have a font with Japanese characters like `æœˆ`. You are serving a page that is in English. It is unlikely you will ever use these Japanese characters. So you can subset your font to contain only simple Latin characters.

That will naturally reduce the size of the font file. Use tools like [glyphhanger](https://github.com/zachleat/glyphhanger) or [subfont](https://github.com/Munter/subfont) to subset fonts.

Let's subset `Jost-400-Book.ttf`. You can download it from [here](https://indestructibletype.com/Jost.html).

```shell
# install glyphhanger
npm i -g glyphhanger

# install fonttools
pip install fonttools

# subsetting Jost-400-Book.ttf font to Latin charset
glyphhanger --LATIN --subset=Jost-400-Book.ttf
```

The above script results in a TTF file (`Jost-400-Book-subset.ttf`) of size `40.5 kb` from `88.7 kb`! Already a reduction of 54%!

> There are online tools like [Charset checker](https://www.alphabet-type.com/tools/charset-checker) to check the charset of fonts. You can use this to verify if the subsetted font matches your required charset or not.

### WOFF2 compression

WOFF2 is a compressed font format that can compress a TTF font.

Let's use our subset font (`Jost-400-Book-subset.ttf`) and compress it to woff2.

```shell
# clone woff2
git clone --recursive https://github.com/google/woff2.git

# enter into the cloned repo
cd woff2

# build
make clean all

# convert the font
./woff2_compress ~/Jost-400-Book-subset.ttf
```

This results in a woff2 file (`Jost-400-Book-subset.woff2`) of size `15.3 kb` from `40.5 kb`! A whopping decrease of 62% and 82% decrease compared to the original font file `Jost-400-Book.ttf`!

> If you are using `glyphhanger` for font subsetting, you can also compress to woff2 directly in a single command!
>
> `glyphhanger --LATIN --subset=Jost-400-Book.ttf --formats=woff2`

# Loading the fonts

Let's see how we can load and use a font.

```css
@font-face {
  font-family: Jost;
  font-weight: 400;
  font-display: swap;
  font-style: normal;
  src: url("/fonts/Jost/Jost-400.woff2") format("woff2");
}

.custom-font {
  font-family: Jost;
}
```

The `@font-face` rule changes a bit when loading variable fonts.

```css
@font-face {
  font-family: Jost;
  font-weight: 300 800; /* specify weight range of the font */
  font-display: swap;
  font-style: normal;
  src: url("/fonts/Jost/Jost-VF.woff2") format("woff2 supports variations"), url("/fonts/Jost/Jost-VF.woff2")
      format("woff2-variations");
}
```

This specifies that a font located at `/fonts/Jost/Jost-400.woff2`, of `woff2` type, with `400` weight, and `normal` style is referenced as `Jost`. Now we can use our font anywhere by setting `font-family: Jost;`. Browsers download fonts only if a styling on the page references them. In this case, the browser will only download the Jost font if the page has an element with class `.custom-font`.

The `font-display` property tells the browser when to render the font once it is loaded. It accepts the following values:

### `auto`

This is browser default.

### `swap`

The fallback font will be used immediately. Once the custom font downloads, it swaps the font. It can cause 'Flash of Unstyled Text' or [FOUT](https://css-tricks.com/fout-foit-foft/). Use `swap` only when the font is absolutely necessary. Make sure to deliver the font early enough to prevent layout shifts.

<ImageSection
  baseUrl="/img/optimizing-fonts-for-the-web"
  srcLight="swap-1.png"
  srcDark="dark-swap-1.png"
  width={927}
  height={253}
  title={
    "Fallback font rendered immediately, swapped with font once it downloads"
  }
/>

### `block`

Displays invisible text for a. Once the custom font downloads, it swaps the font. It can cause 'Flash of Invisible Text' or [FOIT](https://css-tricks.com/fout-foit-foft/).

<ImageSection
  baseUrl="/img/optimizing-fonts-for-the-web"
  srcLight="block-1.png"
  srcDark="dark-block-1.png"
  width={927}
  height={378}
  title={
    "Text rendered in fallback font with invisible ink. Font not yet downloaded, so fallback font is rendered and swapped with font after it downloads."
  }
/>

<ImageSection
  baseUrl="/img/optimizing-fonts-for-the-web"
  srcLight="block-2.png"
  srcDark="dark-block-2.png"
  width={927}
  height={278}
  title={
    "Font downloaded (or was available from cache) before swap period, visibile text rendered."
  }
/>

### `fallback`

Blocks rendering for a short time (100ms). If the font is still not downloaded, use the fallback font. Gives a swap period of about 3 seconds for the custom font to load. If it doesn't load within the swap period, it will not be used.

<ImageSection
  baseUrl="/img/optimizing-fonts-for-the-web"
  srcLight="fallback-1.png"
  srcDark="dark-fallback-1.png"
  width={929}
  height={379}
  title={
    "Text rendered in fallback font with invisible ink. Font not yet downloaded font after block period, so fallback font rendered in visible ink. Font downloaded in swap period and rendered."
  }
/>

<ImageSection
  baseUrl="/img/optimizing-fonts-for-the-web"
  srcLight="fallback-2.png"
  srcDark="dark-fallback-2.png"
  width={929}
  height={279}
  title={
    "Text rendered in fallback font with invisible ink. Font downloaded before swap period, and rendered in visible ink."
  }
/>

<ImageSection
  baseUrl="/img/optimizing-fonts-for-the-web"
  srcLight="fallback-3.png"
  srcDark="dark-fallback-3.png"
  width={929}
  height={404}
  title={
    "Text rendered in fallback font with invisible ink. Font not yet downloaded font after block period, so fallback font rendered in visible ink. Font not yet downloaded in swap period, continue using fallback font."
  }
/>

### `optional`

Like `fallback`, it blocks for a while and displays the fallback if the custom font is not yet downloaded. But, the browser decides whether to swap the downloaded custom font depending on the connection speed.

# Preloading?

Sometimes, the absence of fonts can make your page unusable. It might be a no-brainer to load them asap because you know you WILL use them. We can `preload` fonts by adding a `<link>` in the `<head>` with `preload` hint. This way, instead of the font to be discovered via stylesheet and downloaded, the browser will download the font at the earliest.

> Preloaded resources are cached on the browsers for future requests.

```html
<head>
  <link
    rel="preload"
    href="/fonts/Jost/Jost-400.woff2"
    as="font"
    type="font/woff2"
    crossorigin
  />
</head>
```

But this comes at a cost ðŸ˜”. `preload`ing resources might obstruct other critical resources for the page. If at all you end up `preload`ing fonts, make sure your longest critical chain is short.

When loading fonts from a 3rd party origin, you can `preconnect` to establish an early connection. Below is an example with Google Fonts.

```html
<head>
  <!-- preconnect origin serving stylesheets -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />

  <!-- preconnect origin serving fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <!-- loading stylesheets -->
  <link
    href="https://fonts.googleapis.com/css2?family=Jost&display=swap"
    rel="stylesheet"
  />
</head>
```

Note that links with `prefetch` and `preconnect` hints are executed as the browser sees fit. Whereas `preload` is mandatory. Modern web browsers already have good prioritization and do not need `preload`s. But if you want some critical resource to be downloaded at the earliest, you can use it sparingly.

> `preconnect` for fonts needs a `crossorigin` attribute because, unlike stylesheets, font files are served over [CORS connection](https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements).

# Conclusion

How does all this fix the 2 issues we discussed in the begining?

- ### Faster text rendering

  A font will render faster if it is downloaded faster. Use variable fonts when needing multiple font styles. Subset and convert fonts to woff2 for the smallest font file size. Serve them over a CDN and HTTP/2 protocol for the fastest and most reliable speeds. `preload` fonts when serving them or `preconnect` fonts/stylesheets when using 3rd party services. When preloading, make sure your longest critical chain is the smallest possible

- ### Layout shifts

  If the custom font is not a top priority, use `font-display: optional`. This guarantees no layout shifts. But if the custom font is a top priority, use `font-display: swap` with the above optimizations for the font delivery.
